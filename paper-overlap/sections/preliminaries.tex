%!TEX root = ../main/main.tex

\paragraph{Sets and intervals} Given a set $A$, we denote by $2^\textit{A}$ the $powerset$ of $A$. We denote by $\mathbb{N}$ the natural numbers. Given $n,m \in \mathbb{N}$ with $n \leq m$, we denote by  [$n$] the set \{$1,\dots,n$\} and by [$n..m$] the interval \{$n,n+1,\dots,m$\} over $\mathbb{N}$. %We denote by $\mathbb{Q}_{\geq 0}$ the non-negative rational numbers, and by $\mathbb{Q}_{\geq 0}^\infty$ the set $\mathbb{Q}_{\geq 0} \cup \{\infty\}$ where $q < \infty$ for every $q \in \mathbb{Q}_{\geq 0}$. A subset $I \subseteq$ $\mathbb{Q}_{\geq 0}$ is an \textit{interval over} $\mathbb{Q}_{\geq 0}$ if for every $p, q \in I$ and $r \in \mathbb{Q}_{\geq 0}$, if $p \leq r \leq q$, then $r \in I$. We will use the standard notation for specifying  intervals over $\mathbb{Q}_{\geq 0}$, namely, as pairs in $\mathbb{Q}_{\geq 0}$ $\times$ $\mathbb{Q}_{\geq 0}^\infty$ with squared or circled brackets.

\paragraph{Events and streams} We fix a set \textbf{T} of \textit{event types}, a set \textbf{A} of \textit{attributes names}, and a set \textbf{D} of \textit{data values} (e.g., integers, floats, strings). An \textit{event} $e$ is a partial mapping $e$ : \textbf{A} $\rightarrow$ \textbf{D} that maps attributes names in \textbf{A} to data values in \textbf{D}. We denote att(e) the domain of $e$, called the attributes of $e$, and we assume that att(e) is finite. We denote by  $e(A)$ the data value of the attribute $A \in$ \textbf{A} whenever $A \in att(e)$. Further, each event $e$ has a type in \textbf{T} denoted by type(e). We write \textbf{E} to denote the set of all events over event types \textbf{T}, attributes names \textbf{A}, and data values \textbf{D}. A \textit{stream} is an (arbitrary long) sequence $\bar{S} = e_1 e_2 \dots e_n$ of events where $|S| = n$ is the length of the stream. % We define the size $|e|$ of an event $e$ as the number of RAM registers to encode $e$.

\paragraph{Complex events} Fix a finite set \textbf{X} of variables and assume that \textbf{T} $\subseteq$ \textbf{X}, where \textbf{T} is the set of event types as defined earlier, this is to say that all event types are a variable. Let $\bar{S}$ be a stream of length $n$. A complex event of $\bar{S}$ is a triple $(i, j, \mu)$ where $i, j \in$ [$n$], $i \leq j$, and $\mu$ : \textbf{X} $\rightarrow$ $2^{[i..j]}$ is a function with finite domain. Intuitively, $i$ and $j$ marks the beginning and end of the interval where the complex event happens, and $\mu$ stores the events in the interval [$i..j$] that fired the complex event. In the following, we will usually use $C$ to denote a complex  event $(i, j, \mu)$ of $\bar{S}$ and omit $\bar{S}$ if the stream is clear from the context. We will use interval($C$), start($C$), and end($C$) to denote the interval [$i..j$], the start $i$, and the end $j$ of $C$, respectively. Further, by some abuse of notation we will also use C(X) for $X \in$ \textbf{X} to denote the set $\mu(X)$ of $C$. 

The following operations on complex events will be useful throughout the paper. We define the union of complex events $C_1$ and $C_2$, denoted by $C_1 \cup C_2$, as the complex event $C'$ such that start($C'$) =  min\{start($C_1$),start($C_2$)\}, end(C') = max\{end($C_1$), end($C_2$)\}, and $C'$(X) = $C_1(X) \cup C_2(X)$ for every $X \in$ \textbf{X}. Further, we define the \textit{projection over} $L$ of a complex event $C$, denoted by $\pi_L$(C), as the complex  event $C'$ such that interval($C'$) = interval($C$) and $C'$(X) = C(X) whenever $X \in$ $L$, and C'(X) = $\emptyset$, otherwise. Finally, we denote by $(i, j, \mu_\emptyset)$ the complex event with trivial mapping $\mu_\emptyset$ such that $\mu_\emptyset$(X) = $\emptyset$ for every $X \in$ \textbf{X}.

\paragraph{Predicate of events} A \textit{predicate} is a possibly infinite set \textbf{P} of events. We say that an event $e$ satisfies predicate $P$, denoted $e \vDash P$, if, and only if, $e \in P$. We generalize this notation from events to a set of events $E$ such that $E \vDash P$ if, and only if, $e \vDash P$ for every $e \in E$. We assume a fixed set of predicates \textbf{P}. Further, we assume that there is a basic set of predicates \textbf{$P_basic$} $\subseteq P$ and \textbf{P} is the closure of \textbf{$P_basic$} under intersection and negation (i.e., $P_1 \cap P_2 \in$ \textbf{P} and \textbf{E}$\ P \in$ \textbf{P} for every $P, P_1, P_2 \in$ \textbf{P}) where \textbf{E} is a predicate in \textbf{P}, that we usually denote by true. %For every $P \in$ \textbf{P}, we define a size of a predicate |P | as follows: |P | = 1 if P ∈ Pbasic (i.e., constant size), |P | = |P1| + |P2| if P = P1 ∩ P2, and |P | = |P ′| + 1 if P = E \ P ′. For every P ∈ P, we assume that the time to check if e |= P is in O(|e|).

\paragraph{Complex event logic} In this work, we use the Complex Event Logic (CEL) introduced in [21] and implemented in CORE [11] as our basic query language for CER. The syntax of a CEL formula $\varphi$ is given by the grammar:  
\[
\makebox[\textwidth][s]{$
	\varphi := R \; \big|\; \varphi \text{ AS } X 
	\; \big|\; \varphi \text{ FILTER } X[P]
	\; \big|\; \varphi \text{ OR } \varphi
	\; \big|\; \varphi \text{ AND } \varphi
	\; \big|\; \varphi ; \varphi
	\; \big|\; \varphi : \varphi
	\; \big|\; \varphi{+}
	\; \big|\; \varphi{\oplus}
	\; \big|\; \pi_L(\varphi)
	$}
\]
where $R \in$ \textbf{T} is an event type, $X \in$ \textbf{X} is a variable, $P \in$ \textbf{P} is a predicate, and $L \subseteq$ \textbf{X} is a set of variables.  We define the semantics of a CEL formula $\varphi$ over a stream $\bar{S}$, recursively, as a set of complex events over  $\bar{S}$ In Figure 1, we define the semantics of each CEL operator like in [11, 21].

\begin{figure}[t]
\[
\begin{aligned}
	\text{\textlbrackdbl} R \text{\textrbrackdbl}(\bar{S}) 
	&= \{\, (i, i, \mu)
	\mid \text{type}(e_i) = R 
	\land \mu(R) = \{i\} 
	\land \forall X \neq R.\ \mu(X) = \emptyset \,\} \\
	\text{\textlbrackdbl} \varphi\ \text{AS}\ X \text{\textrbrackdbl}(\bar{S}) 
	&= \{\, C 
	\mid \exists C' \in \text{\textlbrackdbl} \varphi \text{\textrbrackdbl}(\bar{S}).\
	\text{interval}(C) = \text{interval}(C') 
	\land C(X) = {\bigcup}_Y C'(Y) \\& \hspace{30pt}	
	\land \forall Z \neq X.\ C(Z) = C'(Z) \,\} \\
	\text{\textlbrackdbl} \varphi\ \text{FILTER}\ X[P] \text{\textrbrackdbl}(\bar{S}) 
	&= \{\, C 
	\mid C \in \text{\textlbrackdbl} \varphi \text{\textrbrackdbl}(\bar{S}) 
	\land C(X) \models P \,\} \\
	\text{\textlbrackdbl} \varphi_1\ \text{OR}\ \varphi_2 \text{\textrbrackdbl}(\bar{S}) 
	&= \text{\textlbrackdbl} \varphi_1 \text{\textrbrackdbl}(\bar{S}) 
	\cup 
	\text{\textlbrackdbl} \varphi_2 \text{\textrbrackdbl}(\bar{S}) \\
	\text{\textlbrackdbl} \varphi_1\ \text{AND}\ \varphi_2 \text{\textrbrackdbl}(\bar{S}) 
	&= \text{\textlbrackdbl} \varphi_1 \text{\textrbrackdbl}(\bar{S}) 
	\cap 
	\text{\textlbrackdbl} \varphi_2 \text{\textrbrackdbl}(\bar{S}) \\
	\text{\textlbrackdbl} \varphi_1 ; \varphi_2 \text{\textrbrackdbl}(\bar{S}) 
	&= \{\, C_1 \cup C_2 
	\mid C_1 \in \text{\textlbrackdbl} \varphi_1 \text{\textrbrackdbl}(\bar{S}) 
	\land C_2 \in \text{\textlbrackdbl} \varphi_2 \text{\textrbrackdbl}(\bar{S})
	\land \text{end}(C_1) < \text{start}(C_2) \,\} \\
	\text{\textlbrackdbl} \varphi_1 : \varphi_2 \text{\textrbrackdbl}(\bar{S}) 
	&= \{\, C_1 \cup C_2 
	\mid C_1 \in \text{\textlbrackdbl} \varphi_1 \text{\textrbrackdbl}(\bar{S}) 
	\land C_2 \in \text{\textlbrackdbl} \varphi_2 \text{\textrbrackdbl}(\bar{S})
	\land \text{end}(C_1) + 1 = \text{start}(C_2) \,\} \\
	\text{\textlbrackdbl} \varphi^{+} \text{\textrbrackdbl}(\bar{S}) 
	&= \text{\textlbrackdbl} \varphi \text{\textrbrackdbl}(\bar{S}) 
	\cup 
	\text{\textlbrackdbl} \varphi ; \varphi^{+} \text{\textrbrackdbl}(\bar{S}) \\
	\text{\textlbrackdbl} \varphi^{\oplus} \text{\textrbrackdbl}(\bar{S}) 
	&= \text{\textlbrackdbl} \varphi \text{\textrbrackdbl}(\bar{S}) 
	\cup 
	\text{\textlbrackdbl} \varphi : \varphi^{\oplus} \text{\textrbrackdbl}(\bar{S}) \\
	\text{\textlbrackdbl} \pi_{L}(\varphi) \text{\textrbrackdbl}(\bar{S}) 
	&= \{\, \pi_L(C) 
	\mid C \in \text{\textlbrackdbl} \varphi \text{\textrbrackdbl}(\bar{S}) \,\}
\end{aligned}
\]

\caption{Figure 1: The semantics of CEL formulas defined over a stream $\bar{S} = e_1 e_2\dots e_n$ where each $e_i$ is an event.}
\end{figure}



%Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
%
%\paragraph{Graphs} A graph is a pair $G = (V, E)$ where $V$ is a finite set and $E \subseteq V\times V$ is a finite relation.
%
%\martin{Here a coment from Martin. I think $E$ is always finite if $V$ is finite.}
%
%Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
%
%\paragraph{Numbers} Let $\bbN$, $\bbR$, and $\bbZ$ be the set of natural numbers, reals, and integers.
%Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
%
%\paragraph{Logics} For a given signature $\cL = \langle R_1,\ldots,R_{\ell}\rangle$, a formula in First Order logic (FO) is defined by the following syntax:
%$$
%\varphi := R_i(\bar{x}) \ \mid \ x = y \ \mid \ \varphi \vee \varphi \ \mid \neg \varphi \ \mid \ \exists x.\, \varphi,
%$$
%where $x$ and $y$ are first-order variables, $\bar{x}$ is a $k$-tuple of variables and $R_i$ has arity $k$.
